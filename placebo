#!/usr/bin/env bash

_usage() {
  case $1 in
  "main")
    echo "Usage: . $0 [-h]"
    ;;
  "attach")
    echo "Usage: pill_attach [-h] \
command=aws data_path=path/to/responses"
    ;;
  "playback")
    echo "Usage: pill_playback [-h]"
    echo "Sets Placebo to playback mode"
    ;;
  "record")
    echo "Usage: pill_record [-h]"
    echo "Sets Placebo to record mode"
    ;;
  "detach")
    echo "Usage: pill_detach [-h]"
    echo "Detaches Placebo and cleans \
up functions and variables"
    ;;
  esac
  return 0
}

if [[ "$0" == "${BASH_SOURCE[0]}" ]] ; then
  _usage main
  false
fi

if [ "$1" == "-h" ] ; then
  _usage main
  true
fi

pill_attach() {
  [ "$1" == "-h" ] && \
    _usage attach && return

  # $1 is a placeholder. It is here to
  # provide consistency with Python Placebo,
  # and also allows possible expansion to
  # work with other tools aside from
  # AWS CLI.
  #
  { [ "$1" != "command=aws" ] || \
    ! echo "$2" | grep -q = ; } && \
    _usage attach && return 1

  DATA_PATH=$(echo "$2" | cut -f2 -d=)

  if [ -d "$DATA_PATH" ] ; then
    echo "DATA_PATH should be a path to \
a file but you specified a directory"
    _usage attach && return 1
  fi

  true > commands_log
}

pill_playback() {
  [ "$1" == "-h" ] && \
    _usage playback && return
  PILL=playback
}

pill_record() {
  [ "$1" == "-h" ] && \
    _usage record && return
  PILL=record
}

pill_log() {
  [ "$1" == "-h" ] && \
    _usage log && return
  [ -f commands_log ] && \
    cat commands_log
}

pill_detach() {
  [ "$1" == "-h" ] && \
    _usage detach && return

  local f funcs
  funcs="_usage
pill_attach
pill_playback
pill_record
pill_log
pill_detach
_create_new
_update_existing
_filter
_record
aws"
  for f in $funcs ; do
    unset -f "$f"
  done
  unset PILL
  unset DATA_PATH
  rm -f commands_log
}

aws() {
  if [ -z "$DATA_PATH" ] ; then
    echo "DATA_PATH must be set. \
Try pill_attach"
    return 1
  fi

  if [ -z "$PILL" ] ; then
    echo "PILL must be set to \
playback or record. Try pill_playback \
or pill_record"
    return 1
  fi

  if [ ! -f "$DATA_PATH" -a \
    "$PILL" == "playback" ] ; then
    echo "DATA_PATH not found. Try \
pill_record to record one"
    return 1
  fi

  echo "aws $*" | \
    _filter >> commands_log

  case "$PILL" in
  "playback")
    source "$DATA_PATH" "$@"
    ;;
  "record")
    _record "$DATA_PATH" "$@"
    ;;
  esac
}

# private functions.

_record() {
  local f="$1" ; shift

  [ -s "$f" ] && _update_existing "$f" \
    || _create_new "$f"

  # open another case.
  cat <<EOD | _filter >> "$f"
'aws $@')
  cat <<'EOF'
EOD

  # insert response data.
  command aws "$@" | tee -a "$f"

  # close the case and the block.
  cat >> "$f" <<EOD
EOF
  ;;
*)
  echo "No responses for: aws \$*"
  ;;
esac
EOD
}

_create_new() {
  local f=$1
  mkdir -p "$(dirname "$f")"
  echo 'case "aws $*" in' > "$f"
}

_update_existing() {
  local f=$1
  awk '/^\*\)/{exit}{print}' "$f" > "$f.bak"
  mv "$f.bak" "$f"
}

_filter() {
  sed -e 's/  *$//' \
      -e "s/  *'/'/"
}

# vim: ft=sh
