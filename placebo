#!/usr/bin/env bash

_usage() {
  case "$1" in
  "main")
    echo "Usage: . $0 [-h]"
    ;;
  "attach")
    echo "Usage: pill_attach [-h] \
command=aws data_path=path/to/responses"
    ;;
  "playback")
    echo "Usage: pill_playback [-h]"
    echo "Sets Placebo to playback mode"
    ;;
  "record")
    echo "Usage: pill_record [-h]"
    echo "Sets Placebo to record mode"
    ;;
  "detach")
    echo "Usage: pill_detach [-h]"
    echo "Detaches Placebo and cleans \
up functions and variables"
    ;;
  esac
  return 0
}

if [ "$0" == "${BASH_SOURCE[0]}" ] ; then
  _usage main ; false
fi

if [ "$1" == "-h" ] ; then
  _usage main ; true
fi

pill_attach() {
  [ "$1" == "-h" ] && \
    _usage attach && return

  # $1 is a placeholder. It is here to
  # provide consistency with Python Placebo,
  # and also allows possible expansion to
  # work with other tools aside from
  # AWS CLI.
  #
  { [ "$1" != "command=aws" ] || [[ ! "$2" =~ = ]] ; } \
    && _usage attach && return 1

  DATA_PATH=$(cut -f2 -d= <<< "$2")

  if [ -d "$DATA_PATH" ] ; then
    echo "DATA_PATH should be a path to \
a file but you specified a directory"
    _usage attach && return 1
  fi

  true > commands_log
}

pill_playback() {
  [ "$1" == "-h" ] && \
    _usage playback && return
  PILL=playback
}

pill_record() {
  [ "$1" == "-h" ] && \
    _usage record && return
  PILL=record
}

pill_log() {
  [ "$1" == "-h" ] && \
    _usage log && return
  [ -f commands_log ] && \
    cat commands_log
}

pill_detach() {
  [ "$1" == "-h" ] && \
    _usage detach && return

  local f funcs
  funcs="_usage
pill_attach
pill_playback
pill_record
pill_log
pill_detach
_create_new
_update_existing
_filter
_record
aws"
  for f in $funcs ; do
    unset -f "$f"
  done
  unset PILL
  unset DATA_PATH
  rm -f commands_log
}

aws() {
  if [ -z "$DATA_PATH" ] ; then
    echo "DATA_PATH must be set. \
Try pill_attach"
    return 1
  fi

  if [ -z "$PILL" ] ; then
    echo "PILL must be set to \
playback or record. Try pill_playback \
or pill_record"
    return 1
  fi

  if [ ! -f "$DATA_PATH" -a \
    "$PILL" == "playback" ] ; then
    echo "DATA_PATH not found. Try \
pill_record to record one"
    return 1
  fi

  echo "${FUNCNAME[0]} $*" | \
    _filter >> commands_log

  case "$PILL" in
  "playback")
    source "$DATA_PATH" "$@"
    ;;
  "record")
    _record "$DATA_PATH" "$@"
    ;;
  esac
}

# private functions.

_record() {
  local f="$1" ; shift

  if [ -s "$f" ] ; then
    _update_existing "$f"
  else
    _create_new "$f"
  fi

  # open another case.
  cat <<EOD | _filter >> "$f"
'aws $@')
  cat <<'EOF'
EOD

  # insert response data.
  command aws "$@" | tee -a "$f"

  # close the case and the block.
  cat >> "$f" <<EOD
EOF
  ;;
*)
  echo "No responses for: aws \$*"
  ;;
esac
EOD
}

_create_new() {
  local f="$1"
  mkdir -p "$(dirname "$f")"
  echo 'case "aws $*" in' > "$f"
}

_update_existing() {
  local f="$1"
  awk '/^\*\)/{exit}{print}' "$f" > "$f.bak"
  mv "$f.bak" "$f"
}

_filter() {
  sed "s/  *$//; s/  *'/'/"
}

# vim: ft=sh
