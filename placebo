#!/usr/bin/env bash

_usage() {
  case "$1" in
  "main")
    echo "Usage: . $0 [-h]"
    ;;
  "attach")
    echo "Usage: pill_attach [-h] \
command=command1[,command2,...] data_path=path/to/responses"
    ;;
  "playback")
    echo "Usage: pill_playback [-h]"
    echo "Sets Placebo to playback mode"
    ;;
  "record")
    echo "Usage: pill_record [-h]"
    echo "Sets Placebo to record mode"
    ;;
  "detach")
    echo "Usage: pill_detach [-h]"
    echo "Detaches Placebo and cleans \
up functions and variables"
    ;;
  esac
  return 0
}

if [ "$0" == "${BASH_SOURCE[0]}" ] ; then
  _usage main ; false
fi

if [ "$1" == "-h" ] ; then
  _usage main ; true
fi

pill_attach() {
  [ "$1" == "-h" ] && \
    _usage attach && return

  { [[ ! "$1" =~ command= ]] || [[ ! "$2" =~ = ]] ; } \
    && _usage attach && return 1

  IFS=',' read -r -a COMMANDS <<< "${1#command=}"
  DATA_PATH=$(cut -f2 -d= <<< "$2")

  if [ ! -d "$DATA_PATH" ] ; then
    echo "DATA_PATH should be a path to \
a directory"
    _usage attach && return 1
  fi

  true > commands_log
}

pill_playback() {
  [ "$1" == "-h" ] && \
    _usage playback && return
  PILL=playback
}

pill_record() {
  [ "$1" == "-h" ] && \
    _usage record && return
  # shellcheck disable=SC2034
  PILL=record
}

pill_log() {
  [ "$1" == "-h" ] && \
    _usage log && return
  [ -f commands_log ] && \
    cat commands_log
}

pill_detach() {
  [ "$1" == "-h" ] && \
    _usage detach && return

  local f funcs
  funcs="_usage
pill_attach
pill_playback
pill_record
pill_log
pill_detach
_cli_to_comm
_comm_to_file
_create_new
_update_existing
_filter
_record"
  for f in $funcs "${COMMANDS[@]}"; do
    unset -f "$f"
  done
  unset PILL
  unset DATA_PATH
  rm -f commands_log
}

for c in "${COMMANDS[@]}" ; do
  # shellcheck disable=SC2016,SC1004
  code="$c"'() {
    local file comm

    comm="${FUNCNAME[0]}"
    file=$(_comm_to_file "$comm")

    if [ -z "$DATA_PATH" ] ; then
      echo "DATA_PATH must be set. \
Try pill_attach"
      return 1
    fi

    if [ -z "$PILL" ] ; then
      echo "PILL must be set to \
playback or record. Try pill_playback \
or pill_record"
      return 1
    fi

    if [ ! -f "$file" -a "$PILL" == "playback" ] ; then
      echo "$file not found. \
Make sure you firstly record it"
      return 1
    fi

    echo "$comm $*" | \
      _filter >> commands_log

    case "$PILL" in
    "playback")
      source "$file" "$@"
      ;;
    "record")
      _record "$file" "$comm $*"
      ;;
    esac
  }'
  eval "$code"
done

# private functions.

_cli_to_comm() {
  awk '{print $1}' <<< "$1"
}

_comm_to_file() {
  echo "$DATA_PATH"/"$1".sh
}

_record() {
  local file cli comm
  file="$1" ; cli="$2"
  comm=$(_cli_to_comm "$cli")

  if [ -s "$file" ] ; then
    _update_existing "$comm"
  else
    _create_new "$comm"
  fi

  # TODO. I can capture the response data first,
  # then check its length, then decide if I want
  # the cat <<EOF pattern for multiline, or just
  # echo for single lines, making the generated
  # code cleaner.

  # open another case.
  cat <<EOD | _filter >> "$file"
'$cli')
  cat <<'EOF'
EOD

  # insert response data.
  # shellcheck disable=SC2086
  command $cli | tee -a "$file"

  # close the case and the block.
  cat >> "$file" <<EOD
EOF
  ;;
*)
  echo "No responses for: $comm \$*" | tee -a unknown_commands
  ;;
esac
EOD
}

_create_new() {
  local comm f
  comm="$1" ; f=$(_comm_to_file "$comm")
  # shellcheck disable=SC2086
  echo 'case "'$comm' $*" in' > "$f"
}

_update_existing() {
  local comm f
  comm="$1" ; f=$(_comm_to_file "$comm")
  awk '
    /^\*\)/ {exit}
    {print}
    ' "$f" > "$f.bak"
  mv "$f.bak" "$f"
}

_filter() {
  sed "s/  *$//; s/  *'/'/"
}

# vim: ft=sh
